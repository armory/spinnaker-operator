package integration_tests

import (
	"bufio"
	"encoding/json"
	"fmt"
	"github.com/stretchr/testify/assert"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"
)

const (
	KubeconfigVar        = "KUBECONFIG"
	OperatorImageVar     = "OPERATOR_IMAGE"
	OperatorImageDefault = "armory/spinnaker-operator:dev"
	HalyardImageVar      = "HALYARD_IMAGE"
	HalyardImageDefault  = "armory/halyard:operator-0.3.x"
	BucketVar            = "S3_BUCKET"
	BucketDefault        = "operator-int-tests"
	BucketRegionVar      = "S3_BUCKET_REGION"
	BucketRegionDefault  = "us-west-2"

	OperatorKustomizeBase = "testdata/operator/base"
	CRDManifests          = "../deploy/crds"
)

var envLock sync.Mutex
var envInitialized = false
var operatorRunsByNamespace = map[string]bool{}

// TestEnv holds information about the kubernetes cluster used for tests
type TestEnv struct {
	Operator    Operator
	SpinDeckUrl string
	SpinGateUrl string
	Vars        *Vars
}

// Operator holds information about the operator installation
type Operator struct {
	KustomizationPath string
	OperatorImage     string
	HalyardImage      string
}

type Account struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// Vars are variables used in kustomize templates
type Vars struct {
	Kubeconfig        string
	OperatorImage     string
	HalyardImage      string
	S3Bucket          string
	S3BucketRegion    string
	SpinNamespace     string
	OperatorNamespace string
}

// NewEnv creates a new environment context, with the given operator namespace and path pointing to a kustomize folder
// with operator manifests
func NewEnv(opKust string, t *testing.T) *TestEnv {
	envLock.Lock()
	defer envLock.Unlock()
	vars := resolveEnvVars(t)
	e := &TestEnv{
		Vars: vars,
		Operator: Operator{
			KustomizationPath: opKust,
		},
	}
	if envInitialized {
		t.Logf("Environment already initialized")
		return e
	}
	envInitialized = true
	generateKustomizeBase(t)
	if t.Failed() {
		return nil
	}
	return e
}

func resolveEnvVars(t *testing.T) *Vars {
	k := os.Getenv(KubeconfigVar)
	if k == "" {
		t.Logf("%s env var not set, using default", KubeconfigVar)
		home, err := os.UserHomeDir()
		if !assert.Nil(t, err, "error getting user home") {
			return nil
		}
		k = fmt.Sprintf("%s/.kube/config", home)
	}
	t.Logf("Using kubeconfig %s", k)

	op := os.Getenv(OperatorImageVar)
	if op == "" {
		t.Logf("%s env var not set, using default", OperatorImageVar)
		op = OperatorImageDefault
	}
	t.Logf("Using operator image %s", op)

	h := os.Getenv(HalyardImageVar)
	if h == "" {
		t.Logf("%s env var not set, using default", HalyardImageVar)
		h = HalyardImageDefault
	}
	t.Logf("Using halyard image %s", h)

	b := os.Getenv(BucketVar)
	if b == "" {
		t.Logf("%s env var not set, using default", BucketVar)
		b = BucketDefault
	}
	t.Logf("Using bucekt %s", b)

	r := os.Getenv(BucketRegionVar)
	if r == "" {
		t.Logf("%s env var not set, using default", BucketRegionDefault)
		r = BucketRegionDefault
	}
	t.Logf("Using bucekt region %s", r)
	return &Vars{
		Kubeconfig:     k,
		OperatorImage:  op,
		HalyardImage:   h,
		S3Bucket:       b,
		S3BucketRegion: r,
	}
}

func generateKustomizeBase(t *testing.T) {
	generateBaseKustomization(t)
	if t.Failed() {
		return
	}
	addKustomizationBaseImages(t)
}

func generateBaseKustomization(t *testing.T) {
	kContents := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- deployment.yaml
- service_account.yaml
`
	err := ioutil.WriteFile(filepath.Join(OperatorKustomizeBase, "kustomization.yaml"), []byte(kContents), os.ModePerm)
	if !assert.Nil(t, err, "unable to write base kustomization.yaml file") {
		return
	}
}

func addKustomizationBaseImages(t *testing.T) {
	opImg := os.Getenv(OperatorImageVar)
	if opImg == "" {
		t.Logf("%s env var not set, using default", OperatorImageVar)
		opImg = OperatorImageDefault
	}
	t.Logf("Using operator image %s", opImg)
	halyardImg := os.Getenv(HalyardImageVar)
	if halyardImg == "" {
		t.Logf("%s env var not set, using default", HalyardImageVar)
		halyardImg = HalyardImageDefault
	}
	t.Logf("Using halyard image %s", halyardImg)
	RunCommandAndAssert(fmt.Sprintf("cd %s && kustomize edit set image spinnaker-operator=%s", OperatorKustomizeBase, opImg), t)
	if t.Failed() {
		return
	}
	RunCommandAndAssert(fmt.Sprintf("cd %s && kustomize edit set image halyard=%s", OperatorKustomizeBase, halyardImg), t)
}

func (e *TestEnv) KubectlPrefix() string {
	return fmt.Sprintf("kubectl --kubeconfig=%s", e.Vars.Kubeconfig)
}

func (e *TestEnv) Cleanup(t *testing.T) {
	e.DeleteOperator(t)
}

func InstallCrdsAndOperator(spinNs string, isClusterMode bool, t *testing.T) (e *TestEnv) {
	ns := RandomString("operator")
	if spinNs == "" {
		spinNs = ns
	}
	LogMainStep(t, "Installing CRDs and operator in namespace %s", ns)
	opKustPath := "testdata/operator/overlay_basicmode"
	if isClusterMode {
		opKustPath = "testdata/operator/overlay_clustermode"
	}
	e = NewEnv(opKustPath, t)
	if t.Failed() {
		return
	}
	e.Vars.SpinNamespace = spinNs
	e.Vars.OperatorNamespace = ns
	if isClusterMode {
		e.SubstituteOverlayVars("testdata/operator/overlay_clustermode", t)
	} else {
		e.SubstituteOverlayVars("testdata/operator/overlay_basicmode", t)
	}
	e.SubstituteOverlayVars("testdata/spinnaker/base", t)
	if t.Failed() {
		return
	}
	if !e.InstallCrds(t) {
		return
	}
	e.InstallOperator(t)
	LogMainStep(t, "CRDs and operator installed")
	return
}

func (e *TestEnv) InstallCrds(t *testing.T) bool {
	ApplyManifest("default", CRDManifests, e, t)
	RunCommandAndAssert(fmt.Sprintf("%s get spinsvc", e.KubectlPrefix()), t)
	RunCommandAndAssert(fmt.Sprintf("%s get spinnakeraccounts", e.KubectlPrefix()), t)
	return !t.Failed()
}

func (e *TestEnv) InstallOperator(t *testing.T) bool {
	ran, ok := operatorRunsByNamespace[e.Vars.OperatorNamespace]
	if ok && ran {
		t.Logf("Operator already installed")
		return true
	}
	operatorRunsByNamespace[e.Vars.OperatorNamespace] = true
	if !CreateNamespace(e.Vars.OperatorNamespace, e, t) {
		return !t.Failed()
	}
	if !ApplyKustomizeAndAssert(e.Vars.OperatorNamespace, e.Operator.KustomizationPath, e, t) {
		return !t.Failed()
	}
	return WaitForDeploymentToStabilize(e.Vars.OperatorNamespace, "spinnaker-operator", e, t)
}

func (e *TestEnv) DeleteOperator(t *testing.T) {
	t.Logf("Deleting operator...")
	DeleteNamespace(e.Vars.OperatorNamespace, e, t)
}

func (e *TestEnv) InstallSpinnaker(ns, kustPath string, t *testing.T) bool {
	LogMainStep(t, "Installing spinnaker in namespace %s", ns)
	if !CreateNamespace(ns, e, t) {
		return !t.Failed()
	}
	e.SpinDeckUrl, e.SpinGateUrl = DeploySpinnaker(ns, kustPath, e, t)
	if t.Failed() {
		return !t.Failed()
	}
	LogMainStep(t, "Spinnaker installed successfully")
	return !t.Failed()
}

func (e *TestEnv) VerifyAccountsExist(t *testing.T, accts ...Account) bool {
	LogMainStep(t, "Verifying spinnaker accounts")
	o := ExecuteGetRequest(fmt.Sprintf("%s/credentials", e.SpinGateUrl), t)
	if t.Failed() {
		return !t.Failed()
	}
	var credentials []Account
	found := 0
	if assert.Nil(t, json.Unmarshal([]byte(o), &credentials)) {
		for _, a := range accts {
			for _, c := range credentials {
				if a.Type == c.Type && a.Name == c.Name {
					found++
					break
				}
			}
		}
	}
	assert.Equal(t, len(accts), found, fmt.Sprintf("Unable to find all accounts in spinnaker. Expected: %v but found: %v", accts, credentials))
	return !t.Failed()
}

func (e *TestEnv) GenerateSpinFiles(kustPath, name, filePath string, t *testing.T) bool {
	f := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: spinnaker.io/v1alpha2
kind: SpinnakerService
metadata:
  name: spinnaker
spec:
  spinnakerConfig:
    files:
      %s: |
%s
`
	// read and indent file
	h, err := os.Open(filePath)
	if !assert.Nil(t, err) {
		return !t.Failed()
	}
	s := bufio.NewScanner(h)
	indentedFile := ""
	for s.Scan() {
		indentedFile += fmt.Sprintf("        %s\n", s.Text())
	}
	if !assert.Nil(t, s.Err()) {
		return !t.Failed()
	}

	f = fmt.Sprintf(f, name, string(indentedFile))
	err = ioutil.WriteFile(filepath.Join(kustPath, "files.yml"), []byte(f), os.ModePerm)
	assert.Nil(t, err, "unable to generate files.yml file")
	return !t.Failed()
}

func (e *TestEnv) SubstituteOverlayVars(overlayHome string, t *testing.T) bool {
	fs, err := ioutil.ReadDir(overlayHome)
	if !assert.Nil(t, err) {
		return !t.Failed()
	}
	for _, f := range fs {
		if !strings.Contains(f.Name(), "-template") {
			continue
		}
		tmpl, err := template.New(f.Name()).ParseFiles(filepath.Join(overlayHome, f.Name()))
		if !assert.Nil(t, err) {
			return !t.Failed()
		}
		n := strings.TrimSuffix(f.Name(), filepath.Ext(f.Name()))
		n = strings.ReplaceAll(n, "-template", "")
		p := filepath.Join(overlayHome, fmt.Sprintf("%s-generated%s", n, filepath.Ext(f.Name())))
		gf, err := os.Create(p)
		if !assert.Nil(t, err) {
			return !t.Failed()
		}
		if !assert.Nil(t, tmpl.ExecuteTemplate(gf, f.Name(), e.Vars)) {
			return !t.Failed()
		}
	}
	return !t.Failed()
}
