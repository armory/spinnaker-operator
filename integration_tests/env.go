package integration_tests

import (
	"bufio"
	"encoding/json"
	"fmt"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"os"
	"path/filepath"
	"sync"
	"testing"
)

const (
	KubeconfigVar        = "KUBECONFIG"
	OperatorImageVar     = "OPERATOR_IMAGE"
	OperatorImageDefault = "armory/spinnaker-operator:dev"
	HalyardImageVar      = "HALYARD_IMAGE"
	HalyardImageDefault  = "armory/halyard:operator-0.3.x"
	BucketVar            = "S3_BUCKET"
	BucketDefault        = "operator-int-tests"
	BucketRegionVar      = "S3_BUCKET_REGION"
	BucketRegionDefault  = "us-west-2"

	OperatorKustomizeBase = "testdata/operator/base"
	CRDManifests          = "../deploy/crds"
)

var envLock sync.Mutex
var envInitialized = false
var operatorRunsByNamespace = map[string]bool{}

// TestEnv holds information about the kubernetes cluster used for tests
type TestEnv struct {
	KubeconfigPath string
	Operator       Operator
	SpinDeckUrl    string
	SpinGateUrl    string
}

// Operator holds information about the operator installation
type Operator struct {
	KustomizationPath string
	Namespace         string
	OperatorImage     string
	HalyardImage      string
}

type Account struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// NewEnv creates a new environment context, with the given operator namespace and path pointing to a kustomize folder
// with operator manifests
func NewEnv(opNs, opKust string, t *testing.T) *TestEnv {
	envLock.Lock()
	defer envLock.Unlock()
	k := os.Getenv(KubeconfigVar)
	if k == "" {
		t.Logf("%s env var not set, using default", KubeconfigVar)
		home, err := os.UserHomeDir()
		if !assert.Nil(t, err, "error getting user home") {
			return nil
		}
		k = fmt.Sprintf("%s/.kube/config", home)
	}
	t.Logf("Using kubeconfig %s", k)
	e := &TestEnv{
		KubeconfigPath: k,
		Operator: Operator{
			Namespace:         opNs,
			KustomizationPath: opKust,
		},
	}
	if envInitialized {
		t.Logf("Environment already initialized")
		return e
	}
	envInitialized = true
	generateKustomizeBase(t)
	if t.Failed() {
		return nil
	}
	return e
}

func generateKustomizeBase(t *testing.T) {
	generateBaseKustomization(t)
	if t.Failed() {
		return
	}
	addKustomizationBaseImages(t)
	generateSpinPersistenceConfig(t)
}

func generateBaseKustomization(t *testing.T) {
	kContents := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- deployment.yaml
- service_account.yaml
`
	err := ioutil.WriteFile(filepath.Join(OperatorKustomizeBase, "kustomization.yaml"), []byte(kContents), os.ModePerm)
	if !assert.Nil(t, err, "unable to write base kustomization.yaml file") {
		return
	}
}

func addKustomizationBaseImages(t *testing.T) {
	opImg := os.Getenv(OperatorImageVar)
	if opImg == "" {
		t.Logf("%s env var not set, using default", OperatorImageVar)
		opImg = OperatorImageDefault
	}
	t.Logf("Using operator image %s", opImg)
	halyardImg := os.Getenv(HalyardImageVar)
	if halyardImg == "" {
		t.Logf("%s env var not set, using default", HalyardImageVar)
		halyardImg = HalyardImageDefault
	}
	t.Logf("Using halyard image %s", halyardImg)
	RunCommandAndAssert(fmt.Sprintf("cd %s && kustomize edit set image spinnaker-operator=%s", OperatorKustomizeBase, opImg), t)
	if t.Failed() {
		return
	}
	RunCommandAndAssert(fmt.Sprintf("cd %s && kustomize edit set image halyard=%s", OperatorKustomizeBase, halyardImg), t)
}

func (e *TestEnv) KubectlPrefix() string {
	return fmt.Sprintf("kubectl --kubeconfig=%s", e.KubeconfigPath)
}

func (e *TestEnv) Cleanup(t *testing.T) {
	e.DeleteOperator(t)
}

func InstallCrdsAndOperator(isClusterMode bool, t *testing.T) (e *TestEnv) {
	ns := RandomString("operator")
	LogMainStep(t, "Installing CRDs and operator in namespace %s", ns)
	opKustPath := "testdata/operator/overlay_basicmode"
	if isClusterMode {
		opKustPath = "testdata/operator/overlay_clustermode"
	}
	e = NewEnv(ns, opKustPath, t)
	if t.Failed() {
		return e
	}
	if !e.GenerateOperatorRoleBinding(ns, opKustPath, isClusterMode, t) {
		return
	}
	if !e.InstallCrds(t) {
		return
	}
	e.InstallOperator(t)
	LogMainStep(t, "CRDs and operator installed")
	return
}

func (e *TestEnv) InstallCrds(t *testing.T) bool {
	ApplyManifest("default", CRDManifests, e, t)
	RunCommandAndAssert(fmt.Sprintf("%s get spinsvc", e.KubectlPrefix()), t)
	RunCommandAndAssert(fmt.Sprintf("%s get spinnakeraccounts", e.KubectlPrefix()), t)
	return !t.Failed()
}

func (e *TestEnv) InstallOperator(t *testing.T) bool {
	ran, ok := operatorRunsByNamespace[e.Operator.Namespace]
	if ok && ran {
		t.Logf("Operator already installed")
		return true
	}
	operatorRunsByNamespace[e.Operator.Namespace] = true
	if !CreateNamespace(e.Operator.Namespace, e, t) {
		return !t.Failed()
	}
	if !ApplyKustomizeAndAssert(e.Operator.Namespace, e.Operator.KustomizationPath, e, t) {
		return !t.Failed()
	}
	return WaitForDeploymentToStabilize(e.Operator.Namespace, "spinnaker-operator", e, t)
}

func (e *TestEnv) DeleteOperator(t *testing.T) {
	t.Logf("Deleting operator...")
	DeleteNamespace(e.Operator.Namespace, e, t)
}

func (e *TestEnv) InstallSpinnaker(ns, kustPath string, t *testing.T) bool {
	LogMainStep(t, "Installing spinnaker in namespace %s", ns)
	if !CreateNamespace(ns, e, t) {
		return !t.Failed()
	}
	e.SpinDeckUrl, e.SpinGateUrl = DeploySpinnaker(ns, kustPath, e, t)
	if t.Failed() {
		return !t.Failed()
	}
	LogMainStep(t, "Spinnaker installed successfully")
	return !t.Failed()
}

func (e *TestEnv) VerifyAccountsExist(t *testing.T, accts ...Account) bool {
	LogMainStep(t, "Verifying spinnaker accounts")
	o := ExecuteGetRequest(fmt.Sprintf("%s/credentials", e.SpinGateUrl), t)
	if t.Failed() {
		return !t.Failed()
	}
	var credentials []Account
	found := 0
	if assert.Nil(t, json.Unmarshal([]byte(o), &credentials)) {
		for _, a := range accts {
			for _, c := range credentials {
				if a.Type == c.Type && a.Name == c.Name {
					found++
					break
				}
			}
		}
	}
	assert.Equal(t, len(accts), found, fmt.Sprintf("Unable to find all accounts in spinnaker. Expected: %v but found: %v", accts, credentials))
	return !t.Failed()
}

func (e *TestEnv) GenerateOperatorRoleBinding(ns, kustPath string, isClusterMode bool, t *testing.T) bool {
	rb := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
kind: %sBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: spin-operator-role-binding
subjects:
  - kind: ServiceAccount
    name: spin-operator-sa
    %s
roleRef:
  kind: %s
  name: spin-operator-role
  apiGroup: rbac.authorization.k8s.io
`
	kind := "Role"
	nsLine := ""
	if isClusterMode {
		kind = "ClusterRole"
		nsLine = fmt.Sprintf("namespace: %s", ns)
	}
	rb = fmt.Sprintf(rb, kind, nsLine, kind)
	err := ioutil.WriteFile(filepath.Join(kustPath, "role_binding.yml"), []byte(rb), os.ModePerm)
	assert.Nil(t, err, "unable to generate role_binding file")
	return !t.Failed()
}

func (e *TestEnv) GenerateSpinnakerRoleBinding(ns, kustPath string, t *testing.T) bool {
	rb := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: spin-role-binding
subjects:
  - kind: ServiceAccount
    name: spin-sa
    namespace: %s
roleRef:
  kind: ClusterRole
  name: spin-role
  apiGroup: rbac.authorization.k8s.io
`
	rb = fmt.Sprintf(rb, ns)
	err := ioutil.WriteFile(filepath.Join(kustPath, "role_binding.yml"), []byte(rb), os.ModePerm)
	assert.Nil(t, err, "unable to generate role_binding file")
	return !t.Failed()
}

func generateSpinPersistenceConfig(t *testing.T) bool {
	p := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: spinnaker.io/v1alpha2
kind: SpinnakerService
metadata:
  name: spinnaker
spec:
  spinnakerConfig:
    config:
      persistentStorage:
        s3:
          bucket: %s
`
	b := os.Getenv(BucketVar)
	if b == "" {
		t.Logf("%s env var not set, using default", BucketVar)
		b = BucketDefault
	}
	p = fmt.Sprintf(p, b)
	err := ioutil.WriteFile(filepath.Join("testdata/spinnaker/base", "persistence.yml"), []byte(p), os.ModePerm)
	assert.Nil(t, err, "unable to generate persistence.yml file")
	return !t.Failed()
}

func (e *TestEnv) GenerateSpinFiles(kustPath, name, filePath string, t *testing.T) bool {
	f := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: spinnaker.io/v1alpha2
kind: SpinnakerService
metadata:
  name: spinnaker
spec:
  spinnakerConfig:
    files:
          %s: |
%s
`
	// read and indent file
	h, err := os.Open(filePath)
	if !assert.Nil(t, err) {
		return !t.Failed()
	}
	s := bufio.NewScanner(h)
	indentedFile := ""
	for s.Scan() {
		indentedFile += fmt.Sprintf("            %s\n", s.Text())
	}
	if !assert.Nil(t, s.Err()) {
		return !t.Failed()
	}

	f = fmt.Sprintf(f, name, string(indentedFile))
	err = ioutil.WriteFile(filepath.Join(kustPath, "files.yml"), []byte(f), os.ModePerm)
	assert.Nil(t, err, "unable to generate files.yml file")
	return !t.Failed()
}

func (e *TestEnv) GenerateS3SecretsFile(t *testing.T) bool {
	f := `
# This file is automatically generated by integration tests (env.go), any changes will be lost
apiVersion: spinnaker.io/v1alpha2
kind: SpinnakerService
metadata:
  name: spinnaker
spec:
  spinnakerConfig:
    config:
      providers:
        kubernetes:
          enabled: true
          accounts:
            - name: kube-s3-secret
              providerVersion: V2
              kubeconfigFile: encryptedFile:s3!b:%s!f:secrets/kubeconfig!r:%s
              configureImagePullSecrets: true
              cacheThreads: 1
              namespaces:
                - default
              omitNamespaces: []
              kinds: []
              omitKinds: []
              onlySpinnakerManaged: false
      artifacts:
        github:
          enabled: false
          accounts:
            - name: test-github-account
              token: encrypted:s3!b:%s!f:secrets/secrets.yml!r:%s!k:github.account.token
`
	bucket := os.Getenv(BucketVar)
	if bucket == "" {
		bucket = BucketDefault
	}
	region := os.Getenv(BucketRegionVar)
	if region == "" {
		region = BucketRegionDefault
	}
	f = fmt.Sprintf(f, bucket, region, bucket, region)
	err := ioutil.WriteFile(filepath.Join("testdata/spinnaker/overlay_secrets", "s3_secrets.yml"), []byte(f), os.ModePerm)
	assert.Nil(t, err, "unable to generate s3_secrets.yml file")
	return !t.Failed()
}
